<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Teeko is a solved game</li>
<li>This project implements a minimax algorithm.</li>
<li>It is assumed that the program is always the <b>max</b> player</li>
</ul>
<h2><a class="anchor" id="autotoc_md0"></a>
Summary</h2>
<p >In this assignment, you'll be developing an AI game player for a modified version of the game called Teeko. We call this modified version Teeko2.</p>
<h3><a class="anchor" id="autotoc_md1"></a>
Teeko Rules</h3>
<p >Teeko is the same as tiktactoe except it has a 5x5 gameboard a player wins by placing 4 peices consequtively vertically, horizontally, or diagonally, or by 4 peices in the corners of a 3x3 square configuration (in other words, 4 peices would need ot be placed at (i-1, j-1), (i+1, j-1), (i-1, j+1), (i+1, j+1) respectively, where (i,j) would be the supposed center of the 3x3 square formed by these four peices).</p>
<h3><a class="anchor" id="autotoc_md2"></a>
Provided code</h3>
<p >This week we're providing a basic Python class and some driver code, and it's up to you to finish it so that your player is actually intelligent.</p>
<h3><a class="anchor" id="autotoc_md3"></a>
Make Move</h3>
<p >The <code>make_move(self, state)</code> method begins with the current state of the board. It is up to you to generate the subtree of depth <em>d</em> under this state, create a heuristic scoring function to evaluate the "leaves" at depth <em>d</em> (as you may not make it all the way to a terminal state by depth <em>d</em> so these may still be internal nodes) and propagate those scores back up to the current state, and select and return the best possible next move using the minimax algorithm.</p>
<p >You will be implementing several helper functions for your make_move method to work (for the helper functions, the parameters do not have to be the exact same as the write-up shows because none of those functions are directly tested). </p>
<h4><a class="anchor" id="autotoc_md4"></a>
1\. Generate Successors</h4>
<p >Define a successor function (e.g. <code>succ(self, state)</code> ) that takes in a board state and returns a list of the legal successors. During the drop phase, this simply means adding a new piece of the current player's type to the board; during continued gameplay, this means moving any one of the current player's pieces to an unoccupied location on the board, adjacent to that piece.</p>
<p ><b>Note</b>: wrapping around the edge is NOT allowed when determining "adjacent" positions.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
2\. Evaluate Successors</h4>
<p >Using <code>game_value(self, state)</code> as a starting point, create a function to score each of the successor states. A terminal state where your AI player wins should have the maximal positive score (1), and a terminal state where the opponent wins should have the minimal negative score (-1).</p>
<p >Finish coding the diagonal and 3x3 win condition checks for the game_value method.</p>
<p >Define a <code>heuristic_game_value(self, state)</code> function to evaluate non-terminal states. For some hints, check out Slides 57 and 58 of the Games II Lecture Slides  (You should call the game_value method from this function to determine whether the <b>state</b> is a terminal state before you start evaluating it heuristically.) This function should return some floating-point value between 1 and -1.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
3\. Implement Minimax</h4>
<p >Follow the pseudocode recursive functions on slide #57 of our class lecture,  incorporating the depth cutoff to ensure you terminate in under 5 seconds.</p>
<ul>
<li>Define a <code>max_value(self, state, depth)</code> function where your first call will be  <code>max_value(self, curr_state, 0)</code> and every subsequent recursive call will increase the value of <b>depth</b>.</li>
<li>When the depth counter reaches your tested depth limit OR you find a terminal state, terminate the recursion.</li>
</ul>
<p >We recommend timing your make_move() method (use <a href="https://docs.python.org/3/library/time.html#time.time">Python's time library)</a>  to see how deep in the minimax tree you can explore in under five seconds. Time your function with different values for your depth and pick one that will safely terminate in under 5 seconds. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
